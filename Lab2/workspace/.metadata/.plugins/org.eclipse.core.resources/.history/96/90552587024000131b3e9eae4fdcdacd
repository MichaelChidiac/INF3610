/*
*********************************************************************************************************
*                                                 uC/OS-II
*                                          The Real-Time Kernel
*
*
*
*            					École Polytechnique de Montréal, Qc, CANADA
*                                                  09/2013
*
* File : routeur.C
*********************************************************************************************************
*/

#include "includes.h"
/*
*********************************************************************************************************
*                                              CONSTANTS
*********************************************************************************************************
*/

// Size of each task's stacks (# of WORDs)

#define	UBYTE unsigned char

// Application tasks IDs
#define TASK_STOP_ID    		0
#define TASK_INJECTPACKET_ID  	1
#define TASK_PRINT_ID 			2
#define TASK_COMPUTING_ID     	3
#define TASK_FORWARDING_ID    	4
#define TASK_VERIFICATION_ID 	5

// Application tasks priorities
#define TASK_STOP_PRIO 			0
#define TASK_INJECTPACKET_PRIO 	1
#define TASK_PRINT_PRIO 		2
#define TASK_COMPUTING_PRIO 	3
#define TASK_FOWARDING_PRIO 	4
#define TASK_VERIFICATION_PRIO 	5

#define MUTEX_SOURCE_REJETE_PRIO		9
#define MUTEX_BAD_CRC_PRIO				10
#define MUTEX_PAQUET_REJETE_PRIO		11
#define MUTEX_NB_PACKET_PRIO			12

// Routing info.
#define INT4_LOW  0				/* 0x00000000 */
#define INT4_HIGH 0x3fffffff 	/* 1073741823 */
#define INT3_LOW  0x40000000 	/* 1073741824 */
#define INT3_HIGH 0x7fffffff 	/* 2147483647 */
#define INT2_LOW  0x80000000 	/* 2147483648 */
#define INT2_HIGH 0xC0000000 	/* 3221225472 */
#define INT1_LOW  0xC0000001 	/* 3221225473 */
#define INT1_HIGH 0xffffffff 	/* 4294967295 */

// Reject source info.
#define REJECT_LOW1  0x10000000
#define REJECT_HIGH1 0x100FFFFF
#define REJECT_LOW2  0x50000000
#define REJECT_HIGH2 0x500FFFFF
#define REJECT_LOW3  0x60000000
#define REJECT_HIGH3 0x600FFFFF
#define REJECT_LOW4  0xD0000000
#define REJECT_HIGH4 0xD00FFFFF

#define FIFO_IN_NUM_MSG 	16
#define FIFO_QOS_NUM_MSG 	4

#define CHANNEL1 1

#define High 	0
#define	Medium 	1
#define	Low 	2

typedef struct {
	unsigned int src;
	unsigned int dst;
	unsigned int type;
    unsigned int crc;
 	unsigned int data[12];
}Packet;

/*
*********************************************************************************************************
*                                              VARIABLES
*********************************************************************************************************
*/

/* Declare global variables */
static XGpio LEDS;
static const int LEDMask = 0xff;

OS_STK TaskStopStk[TASK_STK_SIZE];
OS_STK TaskInjectPacketStk[TASK_STK_SIZE];
OS_STK TaskComputingStk[TASK_STK_SIZE];
OS_STK TaskForwardingStk[TASK_STK_SIZE];
OS_STK TaskVerificationStk[TASK_STK_SIZE];
OS_STK TaskPrintStk[TASK_STK_SIZE];

int nbPacket 				= 0; // Nb de packets total traites
int nbPacketLowRejete 		= 0; // Nb de packets low rejetes
int nbPacketMediumRejete 	= 0; // Nb de packets Medium rejetes
int nbPacketHighRejete 		= 0; // Nb de packets High rejetes
int nbPacketCRCRejete 		= 0; // Nb de packets rejetes pour mauvais crc
int nbPacketSourceRejete 	= 0; // Nb de packets rejetes pour mauvaise source

// Print function parameters
typedef struct
{
  unsigned int interfaceID;
  OS_EVENT *Mbox;
  Packet *packet;
} PRINT_PARAM;

typedef enum { false, true } bool;

OS_EVENT *ptrFifoIn;
void *FifoInMsgTbl[FIFO_IN_NUM_MSG];

OS_EVENT *ptrFifoVideo, *ptrFifoAudio, *ptrFifoOtherwise, *ptrFifoAuxilary;
void *FifoInMsgTbl[FIFO_IN_NUM_MSG];
void *FifoVideoMsgTbl[FIFO_QOS_NUM_MSG];
void *FifoAudioMsgTbl[FIFO_QOS_NUM_MSG];
void *FifoOtherwiseMsgTbl[FIFO_QOS_NUM_MSG];
void *FifoAuxilaryMsgTbl[FIFO_QOS_NUM_MSG];

OS_EVENT *SemStop, *SemVerification;
OS_EVENT *MutexSourceRejete, *MutexBadCrc, *MutexPacketRejete, *MutexNbPacket;
OS_EVENT *Int1Mbox, *Int2Mbox, *Int3Mbox, *Int4Mbox,*PacketMbox;

/*
*********************************************************************************************************
*                                         FUNCTION PROTOTYPES
*********************************************************************************************************
*/
/* Function prototypes of tasks */
void initLED();
void TaskInjectPacket(void *data);
void TaskComputing(void *data);
void TaskForwarding(void *data);
void TaskPrint(void *data);
void TaskVerification (void *pdata);
void TaskStop(void *data);
void _CreateTask();
void _DeleteTask();

/*
*********************************************************************************************************
*                                                  MAIN
*********************************************************************************************************
*/
int main (void)
{
	INT8U err;

	 /* Initialize µC/OS-II */
	OSInit();

	BSP_IntDisAll();
    BSP_InitIO();
	
    /* Create Semaphore */
    SemStop 		= OSSemCreate(0);
    SemVerification = OSSemCreate(0);

    initLED();

    /* Create queue */
    ptrFifoIn 			= OSQCreate(&FifoInMsgTbl[0], 			FIFO_IN_NUM_MSG);
    ptrFifoVideo 		= OSQCreate(&FifoVideoMsgTbl[0], 		FIFO_QOS_NUM_MSG);
    ptrFifoAudio 		= OSQCreate(&FifoAudioMsgTbl[0], 		FIFO_QOS_NUM_MSG);
    ptrFifoOtherwise 	= OSQCreate(&FifoOtherwiseMsgTbl[0], 	FIFO_QOS_NUM_MSG);
    ptrFifoAuxilary 	= OSQCreate(&FifoAuxilaryMsgTbl[0], 	FIFO_QOS_NUM_MSG);

    /* Create mailbox */
    Int1Mbox 	= OSMboxCreate((void *)0);
    Int2Mbox 	= OSMboxCreate((void *)0);
    Int3Mbox 	= OSMboxCreate((void *)0);
    Int4Mbox 	= OSMboxCreate((void *)0);
    PacketMbox 	= OSMboxCreate((void *)0);

    /* Create Mutex */
    MutexSourceRejete 	= OSMutexCreate(MUTEX_SOURCE_REJETE_PRIO, &err);
    MutexBadCrc 		= OSMutexCreate(MUTEX_BAD_CRC_PRIO, &err);
    MutexPacketRejete 	= OSMutexCreate(MUTEX_PAQUET_REJETE_PRIO, &err);
    MutexNbPacket		= OSMutexCreate(MUTEX_NB_PACKET_PRIO, &err);

    _CreateTask();

    /* Start Multitasking */
    OSStart();

    return 1;
}

/*
*********************************************************************************************************
*                                              fitTimerHandler
* Ajoutez les xil_printf dans le code de la tâche aux bons endroits
*xil_printf("\nVerification completee %d!\n", i);
*
*********************************************************************************************************
*/
void fitTimerHandler (void* par)
{
#if OS_CRITICAL_METHOD == 3
	OS_CPU_SR cpu_sr = 0;
#endif

	static unsigned int i = 0;
	OS_ENTER_CRITICAL(); /* Disable interrupts */
	if(nbPacketCRCRejete >= 1)
	{
		xil_printf("\nLa tache logicielle taskStop doit etre reveillee, "
				"car le nombre de paquets qui a été rejeté à cause que le CRC était invalide est > 15 (%d)\n.", nbPacketCRCRejete);
		OSSemPost(SemStop);
	}
	OS_EXIT_CRITICAL(); /* Enable interrupts */
	xil_printf("\nVerification completee %d!\n", i++);

}

/*
*********************************************************************************************************
*                                              fitTimer2Handler
* Ajoutez les xil_printf dans le code de la tâche aux bons endroits
*xil_printf("\nLancement tache verification %d!\n", i);
*
*********************************************************************************************************
*/
void fitTimer2Handler (void* par)
{
	static unsigned int i = 0;
	/* devra réveiller la tâche verification pour qu’elle exécute son code */
	OSSemPost(SemVerification);
	xil_printf("\nLancement tache verification %d!\n", ++i);
}

/*
*********************************************************************************************************
*                                              initLED
*********************************************************************************************************
*/
void initLED()
{
	/* Initialize LEDs on the board. */
	XGpio_Initialize(&LEDS, XPAR_LEDS_8BIT_DEVICE_ID);
	XGpio_SetDataDirection(&LEDS, CHANNEL1, 0x00); /* set Leds as output ports */
}

/*
*********************************************************************************************************
*                                              computeCRC
*********************************************************************************************************
*/
unsigned int computeCRC( INT16U* w, int nleft)
{
    unsigned int sum = 0;
    INT16U answer = 0;

    // Adding words of 16 bits
    while (nleft > 1)  {
      sum += *w++;
      nleft -= 2;
    }

    // Handling the last byte
    if (nleft == 1) {
      *(unsigned char *)(&answer) = *(const unsigned char *)w ;
      sum += answer;
    }

    // Handling overflow
    sum = (sum & 0xffff) + (sum >> 16);
    sum += (sum >> 16);

    answer = ~sum;
    return (unsigned int) answer;
}
/*
*********************************************************************************************************
*                                              TaskStop
*Ajoutez les xil_printf dans le code de la tâche aux bons endroits
*xil_printf("ERREUR : Trop de CRC invalide !\n");
*
*********************************************************************************************************
*/
void TaskStop (void *data)
{
	INT8U err;
	OSSemPend(SemStop, 0, &err);
	xil_printf("ERREUR : Trop de CRC invalide !\n Le routeur va s'arreter!\n");
	_DeleteTask();
}

/*
*********************************************************************************************************
*                                              TaskInjectPacket
*********************************************************************************************************
*/
void TaskInjectPacket (void *data)
{
   int i, j;
   INT8U err;

    // Initialization of the rand function
    srand(4600);
    Packet *packet;

    i = 0;
    for (;;) {

    	packet = malloc(sizeof(Packet));

    	// Creating packet
        packet->src = rand();
        packet->dst = 2*(unsigned int)rand();
        packet->type = rand() % 3;		// Three types of packet (High = 0, Medium = 1, Low = 2)

        for(j=0; j<12; j++) {
            packet->data[i] = rand();
        }

        packet->crc = 0;
        if (rand()%10 == 9)			// 10% of Packets with bad CRC
			packet->crc = 1234;
		else
			packet->crc = computeCRC( (INT16U*)(packet), 64 );

		xil_printf("\n********Generation du Paquet # %d ******** \n", ++i);
		xil_printf("ADD 0x%8x \n", packet);
		xil_printf("	** src : 0x%8x \n", packet->src);
		xil_printf("	** dst : 0x%8x \n", packet->dst);
		xil_printf("	** type : %d \n", packet->type);
		xil_printf("	** crc : %8x \n", packet->crc);

		err = OSQPost(ptrFifoIn, packet);

		if (err == OS_ERR_Q_FULL) {
			xil_printf("--TaskInjectPacket: Paquet rejete a l'entree car la fifo est pleine !\n");
		}

		//Packet debit (2 packets per second)
		OSTimeDly(50);
   }
}


/*
*********************************************************************************************************
*                                              TaskComputing
*Ajoutez les xil_printf dans le code de la tâche aux bons endroits
*xil_printf("\n--TaskComputing: Source invalide (Paquet rejete) (total : %d)\n\n", ++nbPacketSourceRejete);
*xil_printf("\n--TaskComputing: CRC invalide (Paquet rejete) (total : %d)\n", ++nbPacketCRCRejete);
*xil_printf("\n--TaskComputing: Fifo high pleine (Paquet rejete) (total : %d) !\n", ++nbPacketHighRejete);
*xil_printf("\n--TaskComputing: Fifo medium pleine (Paquet rejete) (total : %d) !\n", ++nbPacketMediumRejete);
*xil_printf("\n--TaskComputing: Fifo low pleine (Paquet rejete) (total : %d) !\n", ++nbPacketLowRejete);
*														
*********************************************************************************************************
*/
void TaskComputing (void *pdata)
{
#if OS_CRITICAL_METHOD == 3
	OS_CPU_SR cpu_sr = 0;
#endif

	INT8U err;
	void* msg;
	Packet *packet;
	bool bRejectInterval, bRejectInterval1, bRejectInterval2, bRejectInterval3, bRejectInterval4;

	for(;;)
	{
		msg = OSQPend(ptrFifoIn, 0, &err);
		packet = (Packet *)msg;

		/* rejeter les paquets qui ne sont pas dans son espace d’adressage */
		bRejectInterval1 	= packet->src > REJECT_LOW1 && packet->src < REJECT_HIGH1;
		bRejectInterval2 	= packet->src > REJECT_LOW2 && packet->src < REJECT_HIGH2;
		bRejectInterval3 	= packet->src > REJECT_LOW3 && packet->src < REJECT_HIGH3;
		bRejectInterval4 	= packet->src > REJECT_LOW4 && packet->src < REJECT_HIGH4;

		bRejectInterval 	= bRejectInterval1 || bRejectInterval2 || bRejectInterval3 || bRejectInterval4;

		/* tous les paquets ayant une adresse source contenue entre REJECT_LOW et REJECT_HIGH de chaque plage pour les interfaces devront être rejetés */
		if(bRejectInterval)
		{
			OSMutexPend(MutexSourceRejete,0, &err);
			xil_printf("\n--TaskComputing: Source invalide (Paquet rejete) (total : %d)\n\n", ++nbPacketSourceRejete);
			OSMutexPost(MutexSourceRejete);
			free(packet); packet = 0;
		}
		else
		{
			/* Les paquets contenant des erreurs sont simplement rejetés*/
			if(packet->crc == 1234)
			{
				OS_ENTER_CRITICAL();
				xil_printf("\n--TaskComputing: CRC invalide (Paquet rejete) (total : %d)\n", ++nbPacketCRCRejete);
				OS_EXIT_CRITICAL();
				free(packet); packet = 0;
			}
			else
			{
				/* selon le type de paquets (vidéo, audio et autres, respectivement 1, 2 et 3), les paquets valides seront envoyés dans trois queues différentes */
				/* Si les queues sont pleines vous devrez rajouter les paquets dans une queue qui sera lu par la tâche verification.*/
				/* Si cette queue est pleine aussi, vous devez détruire le paquet */
				switch(packet->type)
				{
				case High:
					err = OSQPost(ptrFifoVideo, packet);
					if (err == OS_ERR_Q_FULL)
					{
						err = OSQPost(ptrFifoAuxilary, packet);
						if (err == OS_ERR_Q_FULL)
						{
							OSMutexPend(MutexPacketRejete,0, &err);
							xil_printf("\n--TaskComputing: Fifo high pleine (Paquet rejete) (total : %d) !\n", ++nbPacketHighRejete);
							free(packet); packet = 0;
							OSMutexPost(MutexPacketRejete);
						}
					}
					break;

				case Medium:
					err = OSQPost(ptrFifoAudio, packet);
					if (err == OS_ERR_Q_FULL)
					{
						err = OSQPost(ptrFifoAuxilary, packet);
						if (err == OS_ERR_Q_FULL)
						{
							OSMutexPend(MutexPacketRejete,0, &err);
							xil_printf("\n--TaskComputing: Fifo medium pleine (Paquet rejete) (total : %d) !\n", ++nbPacketMediumRejete);
							free(packet); packet = 0;
							OSMutexPost(MutexPacketRejete);
						}
					}
					break;

				case Low:
					err = OSQPost(ptrFifoOtherwise, packet);
					if (err == OS_ERR_Q_FULL)
					{
						err = OSQPost(ptrFifoAuxilary, packet);
						if (err == OS_ERR_Q_FULL)
						{
							OSMutexPend(MutexPacketRejete,0, &err);
							xil_printf("\n--TaskComputing: Fifo low pleine (Paquet rejete) (total : %d) !\n", ++nbPacketLowRejete);
							free(packet); packet = 0;
							OSMutexPost(MutexPacketRejete);
						}
					}
					break;

				default:
					break;
				}
			}
		}
	}
}

/*
*********************************************************************************************************
*                                              TaskForwarding
*Ajoutez les xil_printf dans le code de la tâche aux bons endroits
*xil_printf("\n--TaskForwarding: %d paquets envoyes\n\n", ++nbPacket);
*********************************************************************************************************
*/
void TaskForwarding (void *pdata)
{
  INT8U err;
  void* msg;
  Packet *packet;
  int LEDValue = 0;
  PRINT_PARAM printRequest;

  pdata = pdata;

  bool bIntervalValid, bIntervalValid1, bIntervalValid2, bIntervalValid3, bIntervalValid4;

  for(;;)
  {
	  /*
	   * les paquets de haute priorité doivent d’abord être traités.
	   * Si aucun paquet de haute priorité n’est prêt, alors un paquet de moyenne priorité peut être envoyé.
	   * Sinon, un paquet de basse priorité pourra être envoyé
	   */
	  if((msg = OSQAccept(ptrFifoVideo, &err))) {}
	  else if((msg = OSQAccept(ptrFifoAudio, &err))) {}
	  else if((msg = OSQAccept(ptrFifoOtherwise, &err))) {}

	  if((packet = (Packet *)msg))
	  {
		  bIntervalValid1 	= packet->dst > INT1_LOW && packet->dst < INT1_HIGH;
		  bIntervalValid2 	= packet->src > INT2_LOW && packet->dst < INT2_HIGH;
		  bIntervalValid3 	= packet->src > INT3_LOW && packet->dst < INT3_HIGH;
		  bIntervalValid4 	= packet->src > INT4_LOW && packet->dst < INT4_HIGH;

		  /* afin de simuler l’accès à cette table, un wait d’une seconde doit être ajouté */
		  OSTimeDly(OS_TICKS_PER_SEC);

		  bIntervalValid = bIntervalValid1 || bIntervalValid2 || bIntervalValid3 || bIntervalValid4;

		  if(bIntervalValid)
		  {
			  if(bIntervalValid1)
			  {
				  printRequest.interfaceID = 1;
				  printRequest.Mbox = Int1Mbox;
			  }
			  else if(bIntervalValid2)
			  {
				  printRequest.interfaceID = 2;
				  printRequest.Mbox = Int2Mbox;
			  }
			  else if(bIntervalValid3)
			  {
				  printRequest.interfaceID = 3;
				  printRequest.Mbox = Int3Mbox;
			  }
			  else if(bIntervalValid4)
			  {
				  printRequest.interfaceID = 4;
				  printRequest.Mbox = Int4Mbox;
			  }

			  /* la communication via la tâche forwarding et l’interface se fera par un mailbox*/
			  err = OSMboxPost(PacketMbox, &printRequest);
			  if(err == OS_FALSE)
			  {
				  xil_printf("Impossbile d'envoyer le paquet a l'interface.\n");
				  free(packet); packet = 0;
			  }
			  else
			  {
				  /* tâche forwarding met à jour une variable globale du nom de nbPacket indiquant le nombre total de paquets traités et écrire sur les DELs la valeur du nbPacket */
				  err = OSMboxPost(printRequest.Mbox, packet);
				  OSMutexPend(MutexNbPacket,0, &err);
				  xil_printf("\n--TaskForwarding: %d paquets envoyes\n\n", ++nbPacket);
				  LEDValue = LEDMask & nbPacket;
				  OSMutexPost(MutexNbPacket);
				  XGpio_DiscreteWrite(&LEDS, CHANNEL1, LEDValue);

			  }
		  }
	  }
  }
}

/*
*********************************************************************************************************
*                                              TaskVerification
*Ajoutez les xil_printf dans le code de la tâche aux bons endroits
*		xil_printf("\n********Remise du Paquet # %d ******** \n", ++i);
		xil_printf("	** src : 0x%8x \n", packet->src);
		xil_printf("	** dst : 0x%8x \n", packet->dst);
*********************************************************************************************************
*/
void TaskVerification (void *pdata)
{
	INT8U err;
	void* msg;
	Packet *packet;
	static int i = 0;

	pdata = pdata;

	for(;;)
	{
		OSSemPend(SemVerification, 0, &err); /* s’exécutera périodiquement à toutes les cinq secondes grâce à une synchronisation avec l’interruption du deuxième fit_timer. */
		msg = OSQPend(ptrFifoAuxilary, 0, &err);
		packet = (Packet *)msg;

		switch(packet->type)
		{
			case High:
			err = OSQPost(ptrFifoVideo, packet);
			if (err == OS_ERR_Q_FULL)
			{
				OSMutexPend(MutexPacketRejete,0, &err);
				xil_printf("\n--TaskVerification: Fifo high pleine (Paquet rejete) (total : %d) !\n", ++nbPacketHighRejete);
				OSMutexPost(MutexPacketRejete);
				free(packet); packet = 0;
			}
			break;

			case Medium:
			err = OSQPost(ptrFifoAudio, packet);
			if (err == OS_ERR_Q_FULL)
			{
				OSMutexPend(MutexPacketRejete, 0, &err);
				xil_printf("\n--TaskVerification: Fifo medium pleine (Paquet rejete) (total : %d) !\n", ++nbPacketMediumRejete);
				OSMutexPost(MutexPacketRejete);
				free(packet); packet = 0;
			}
			break;

			case Low:
			err = OSQPost(ptrFifoOtherwise, packet);
			if (err == OS_ERR_Q_FULL)
			{
				OSMutexPend(MutexPacketRejete,0, &err);
				xil_printf("\n--TaskVerification: Fifo low pleine (Paquet rejete) (total : %d) !\n", ++nbPacketLowRejete);
				OSMutexPost(MutexPacketRejete);
				free(packet); packet = 0;
			}
			break;

			default:
				break;
		}

		if (packet)
		{
			xil_printf("\n********Remise du Paquet # %d ******** \n", ++i);
			xil_printf("	** src : 0x%8x \n", packet->src);
			xil_printf("	** dst : 0x%8x \n", packet->dst);
		}
	}
}


/*
*********************************************************************************************************
*                                              TaskPrint
*********************************************************************************************************
*/
void TaskPrint(void *data)
{
  INT8U err;
  void* msg;
  Packet *packet;
  int interfaceID;

  data = data;

  for (;;)
  {
	  OSMboxAccept(Int1Mbox);

	  if(msg != (void *)0)
	  {
		  packet = (Packet*)msg;
		  xil_printf("\nPaquet recu en %d \n", interfaceID);
		  xil_printf("	>> src : 0x%8x \n", packet->src);
		  xil_printf("	>> dst : 0x%8x \n", packet->dst);
		  xil_printf("	>> type : %d \n", packet->type);
		  free(packet); packet = 0;
	  }
  }
}

void _CreateTask()
{
	OSTaskCreateExt(
			TaskVerification,
			(void *)0,									// Utilisé pour passer des paramètres à la tâche au début de l'exécution.
			&TaskVerificationStk[TASK_STK_SIZE-1], 		// Pointeur au top du stack
			(INT8U)(TASK_VERIFICATION_PRIO),			// La priorité unique de la tâche
			(INT16U)(TASK_VERIFICATION_ID),				// Le numéro d'identification de la tâche
			&TaskVerificationStk[0],					// Pointeur au bottom du stack
			TASK_STK_SIZE,								// Taille de la pile
			(void *)0,									// TCB Extension
			OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR 	// Option Stack checking enabled
			);

	OSTaskCreateExt(
			TaskStop,
			(void *)0,
			&TaskStopStk[TASK_STK_SIZE-1],
			(INT8U)(TASK_STOP_PRIO),
			(INT16U)(TASK_STOP_ID),
			&TaskStopStk[0],
			TASK_STK_SIZE,
			(void *)0,
			OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR
			);

	OSTaskCreateExt(
			TaskInjectPacket,
			(void *)0,
			&TaskInjectPacketStk[TASK_STK_SIZE-1],
			(INT8U)(TASK_INJECTPACKET_PRIO),
			(INT16U)(TASK_INJECTPACKET_ID),
			&TaskInjectPacketStk[0],
			TASK_STK_SIZE,
			(void *)0,
			OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR
		);

	OSTaskCreateExt(
			TaskComputing,
			(void *)0,
			&TaskComputingStk[TASK_STK_SIZE-1],
			(INT8U)(TASK_COMPUTING_PRIO),
			(INT16U)(TASK_COMPUTING_ID),
			&TaskComputingStk[0],
			TASK_STK_SIZE,
			(void *)0,
			OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR
		);

	OSTaskCreateExt(
			TaskForwarding,
			(void *)0,
			&TaskForwardingStk[TASK_STK_SIZE-1],
			(INT8U)(TASK_FOWARDING_PRIO),
			(INT16U)(TASK_FORWARDING_ID),
			&TaskForwardingStk[0],
			TASK_STK_SIZE,
			(void *)0,
			OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR
		);

	OSTaskCreateExt(
			TaskPrint,
			(void *)0,
			&TaskPrintStk[TASK_STK_SIZE-1],
			(INT8U)(TASK_PRINT_PRIO),
			(INT16U)(TASK_PRINT_ID),
			&TaskPrintStk[0],
			TASK_STK_SIZE,
			(void *)0,
			OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR
			);
}

void _DeleteTask()
{
	INT8U err;
	err = OSTaskDelReq(TASK_STOP_PRIO);
	err = OSTaskDelReq(TASK_INJECTPACKET_PRIO);
	err = OSTaskDelReq(TASK_PRINT_PRIO);
	err = OSTaskDelReq(TASK_COMPUTING_PRIO);
	err = OSTaskDelReq(TASK_FOWARDING_PRIO);
	err = OSTaskDelReq(TASK_VERIFICATION_PRIO);
}
